
(cursor.getPosition().findIntersection(testSlime.getPosition())) easy collision








Caveman cheat sheet for smart pointers
You got it, Jared 😄  
Here’s your **"Smart Pointer Caveman Cheat Sheet"** — like I’m explaining it to a caveman who just learned chairs exist. 🪑🪨

---

### 🧠 Caveman Brain Level: What is a Pointer?

👴 Caveman say:

> “Me want keep Sprite in cave. Me point at Sprite with stick.”

In code:
```cpp
sf::Sprite* sprite; // 🪨 Stick point at Sprite
```

But caveman must remember to **clean up** Sprite or big fire (memory leak)! 🔥

---

### 🧠 What is `std::unique_ptr`?

👴 Caveman discover **smart stick**:

> “Smart stick hold Sprite. Smart stick clean up Sprite when Sprite not needed.”

In code:
```cpp
std::unique_ptr<sf::Sprite> sprite;
```

This means:
✅ It owns the sprite.  
✅ It deletes it **automatically** when done.  
❌ You can’t copy it (it’s unique).

---

### 🧪 How Caveman Use It:

#### 🪄 Make new Sprite:
```cpp
sprite = std::make_unique<sf::Sprite>();
```

#### 🧷 Use like regular pointer:
```cpp
sprite->setPosition(50, 100);
window.draw(*sprite);  // Use * to give the actual Sprite to SFML
```

---

### 📦 Caveman Rules:

| Caveman Want To...         | Code Example                                   |
|----------------------------|------------------------------------------------|
| Make smart Sprite stick    | `std::unique_ptr<sf::Sprite> s;`              |
| Create new Sprite inside   | `s = std::make_unique<sf::Sprite>();`         |
| Use Sprite functions       | `s->move(10, 0);`                              |
| Draw to window             | `window.draw(*s);`                             |
| Smart stick clean up?      | YES. When it leaves scope, Sprite is deleted. |

---

### ❗ Extra Caveman Tips

- Don’t write `*` in the declaration — smart stick already know it hold thing.
- Don’t copy smart stick — only **one** caveman own it at a time.
- Use `->` to talk to the Sprite.
- Use `*sprite` only when **something else wants the real thing**, like `window.draw(*sprite)`.

---

Let me know if Caveman Jared want to move Sprite, eat Sprite, or make many Sprites walk across cave. 🪨











_________________________________________________

class Skeleton {
public:
	// Constructor takes a texture reference and initializes the sprite
	Skeleton(sf::Texture& texture);

	// Method to get the sprite
	sf::Sprite& getSprite();

private:
	sf::Sprite sprite;  // Sprite for the skeleton
};



class EntitySpawner
{
public:
	EntitySpawner();  // Constructor declaration
	void spawnSkeletons();  // Method declaration
	void drawSkeletons(sf::RenderWindow& window);  // Method to draw skeletons

private:
	sf::Texture skeletonTexture;  // Texture for the skeleton
	std::vector<std::unique_ptr<Skeleton>> skeletons;  // Vector of unique pointers to Skeleton
};

____________________________________________________________________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________________________________________________________________________________






 // Update the delta time
            Time dt = clock.restart();

			    // Update the total game time
            gameTimeTotal += dt;

			
            // Make a fraction of 1 from the delta time
            float dtAsSeconds = dt.asSeconds();


			// Update the player
            player.update(dtAsSeconds, Mouse::getPosition());

			 // We will call this function once every frame
    void update(float elapsedTime, Vector2i mousePosition);
			const float START_SPEED = 200;

			void Player::update(float elapsedTime, Vector2i mousePosition)
			 // Calculate the angle the player is facing
			  if (m_UpPressed)
    {
        m_Position.y -= m_Speed * elapsedTime;
    }
    if (m_DownPressed)
    {
        m_Position.y += m_Speed * elapsedTime;
    }
    if (m_RightPressed)
    {
        m_Position.x += m_Speed * elapsedTime;
    }
    if (m_LeftPressed)
    {
        m_Position.x -= m_Speed * elapsedTime;
    }
    m_Sprite.setPosition(m_Position);
    // Keep the player in the arena
    if (m_Position.x > m_Arena.width - m_TileSize)
    {
        m_Position.x = m_Arena.width - m_TileSize;
    }
    if (m_Position.x < m_Arena.left + m_TileSize)
    {
        m_Position.x = m_Arena.left + m_TileSize;
    }
    if (m_Position.y > m_Arena.height - m_TileSize)
    {
        m_Position.y = m_Arena.height - m_TileSize;
    }
    if (m_Position.y < m_Arena.top + m_TileSize)
    {
        m_Position.y = m_Arena.top + m_TileSize;
    }


    float angle = (atan2(mousePosition.y - m_Resolution.y / 2,
        mousePosition.x - m_Resolution.x / 2)
        * 180) / 3.141;


    m_Sprite.setRotation(angle);



